type Donation @entity(immutable: false) {
  id: ID!
  donor: User! 
  amount: BigInt!
  timestamp: BigInt!
  totalDonation: BigInt!
}

type Borrow @entity(immutable: false) {
  id: ID!
  borrower: User! 
  amount: BigInt!
  timestamp: BigInt!
  totalBorrowing: BigInt!
}

type Repayment @entity(immutable: false) {
  id: ID!
  borrower: User! 
  amount: BigInt!
  timestamp: BigInt!
  remainingDebt: BigInt!
}

type User @entity(immutable: false) {
  id: ID!
  totalDonated: BigInt!
  totalBorrowed: BigInt!
  currentDebt: BigInt!
  lastActivity: BigInt!
  donations: [Donation!]! @derivedFrom(field: "donor")
  borrows: [Borrow!]! @derivedFrom(field: "borrower")
  repayments: [Repayment!]! @derivedFrom(field: "borrower")
}

type Stats @entity(immutable: false) {
  id: ID!
  totalDonations: BigInt!
  totalBorrowed: BigInt!
  availableBalance: BigInt!
}

# loan request entity (one per requisition)
type LoanRequest @entity(immutable: false) {
  id: ID!
  requisitionId: BigInt!
  borrower: User!
  amount: BigInt!
  timestamp: BigInt!
  # sum of coverage amounts (wei)
  currentCoverageAmount: BigInt!
  # number of distinct lenders who covered this requisition
  coveringLendersCount: Int!
  # whether the loan was funded (minimum coverage reached and _fundLoan called)
  funded: Boolean!
  fundedAt: BigInt
  # derived list of coverage entries
  coverages: [LoanCoverage!]! @derivedFrom(field: "loanRequest")
  # parcelsCount isn't emitted in LoanRequisitionCreated but is available later in LoanContractGenerated
  parcelsCount: Int          
  # optional list of covering lenders addresses (we only populate coveringLendersCount and LoanCoverage entities from events)
  coveringLenders: [User!] 
}

# per-lender coverage record (accumulates if same lender covers multiple times)
type LoanCoverage @entity(immutable: false) {
  id: ID!
  loanRequest: LoanRequest!
  lender: User!
  amount: BigInt!
  timestamp: BigInt!
}

# loan contract entity created when loan contract is generated on-chain
type LoanContract @entity(immutable: false) {
  id: ID!
  walletAddress: User!
  requisitionId: BigInt!
  status: Int!           # ContractStatus encoded as integer in event
  parcelsPending: Int!   # number of parcels pending
  parcelsValues: BigInt # new field for value per parcel
  createdAt: BigInt!     # timestamp when LoanContractGenerated fired
  completedAt: BigInt    # optional, set when LoanCompleted event fires
}


type ParcelPayment @entity(immutable: false) {
  id: ID!
  requisitionId: BigInt!
  borrower: User!
  amount: BigInt!
  timestamp: BigInt!
  parcelsRemaining: Int!
}

type LenderRepayment @entity(immutable: false) {
  id: ID!
  requisitionId: BigInt!
  lender: User!
  amount: BigInt!
  timestamp: BigInt!
}

# Member entity maps a numeric memberId to a wallet address and stores current reputation
type Member @entity(immutable: false) {
id: ID! # memberId as string (e.g. "1")
memberId: BigInt! # numeric member id
wallet: User # optional relation to User (by wallet address)
linkedAt: BigInt! # timestamp when vinculation happened
currentReputation: Int # updated by ReputationChanged events
}


# ReputationChange logs each reputation update
type ReputationChange @entity(immutable: false) {
id: ID!
memberId: BigInt!
member: Member # derived link not available from event, but we store relation when possible
points: Int!
increase: Boolean!
newReputation: Int!
timestamp: BigInt!
}